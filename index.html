<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="程序媛的日常">
<meta property="og:type" content="website">
<meta property="og:title" content="Luting's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Luting's blog">
<meta property="og:description" content="程序媛的日常">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Luting's blog">
<meta name="twitter:description" content="程序媛的日常">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Luting's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Luting's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-technology">
          <a href="/technology" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-thumbs-up"></i> <br />
            
            技术
          </a>
        </li>
      
        
        <li class="menu-item menu-item-life">
          <a href="/life" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heart"></i> <br />
            
            生活
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T19:38:44+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/14/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/14/hello-world/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to my home!</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/27/C4/" itemprop="url">
                  Ctci 读书笔记（五）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-27T17:36:29+08:00" content="2016-05-27">
              2016-05-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/面试/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/27/C4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/27/C4/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Chapter-4-Trees-and-Graphs"><a href="#Chapter-4-Trees-and-Graphs" class="headerlink" title="Chapter 4 Trees and Graphs"></a>Chapter 4 Trees and Graphs</h2><p>树和图是面试中经常被问到的两种数据结构，常以一下两种方式出现：</p>
<ul>
<li>Implement a tree/find a node/delete a node/other well known algorithm</li>
<li>Implement a modification of a known algorithm<br>在面试前，务必理解掌握树的相关算法。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h4><p>需要注意的是，对于binary tree,面试者经常会把它默认为binary search tree, 然而面试官经常就只是指的是binary tree. 因此面试者要仔细听是否有关键词”search”.实在不清楚的话，需要向面试官提问。<br>关于二叉树，必须熟练掌握的算法：</p>
<ul>
<li>先序遍历(Pre-order)</li>
<li>中序遍历(In-order)</li>
<li>后序遍历(Post-order)</li>
<li>插入节点(向二叉搜索树中插入节点，和根节点比较，如果大于根节点就向右遍历，小于根节点就向左遍历，直到找到一个空位插入。虽然二叉搜索树中节点的调整和删除很少在面试中出现，但是如果你知道具体是如何做的，会让你的表现较其他面试者更加突出)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> TreeNode &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	TreeNode(<span class="keyword">int</span> val) :value(val),left(<span class="literal">NULL</span>),right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderRecursive</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; head-&gt;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	preorderRecursive(head-&gt;left);</span><br><span class="line">	preorderRecursive(head-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"><span class="comment">//非递归先序遍历在第一次访问到节点的时候输出节点，并且从该节点向左和向右依次遍历。因此需要用到一个数据结构可以保存节点信息的，当从左子树返回时可以引导到右子树。stack LIFO的特性可以作为这样的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderIterative</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">	TreeNode* p = head;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty() || p) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			s.push(p);</span><br><span class="line">			p = p-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = s.top();</span><br><span class="line">			s.pop();</span><br><span class="line">			p = p-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderRecursive</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	inorderRecursive(head-&gt;left);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; head-&gt;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	inorderRecursive(head-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"><span class="comment">//非递归中序遍历在第二次访问节点的时候输出节点，因此需要先用栈来保存节点信息，当某一个节点从栈中弹出的时候，就表示该节点已经从左子树中返回，此时访问该节点，并且继续向右遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderIterative</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">	TreeNode* p = head;</span><br><span class="line">	<span class="keyword">while</span> (p || !s.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			s.push(p);</span><br><span class="line">			p = p-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			p = s.top();</span><br><span class="line">			s.pop();</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			p = p-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderRecursive</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	postorderRecursive(head-&gt;left);</span><br><span class="line">	postorderRecursive(head-&gt;right);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; head-&gt;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归实现</span></span><br><span class="line"><span class="comment">//非递归后序遍历较前两种遍历方式特殊。由于节点是在最后一次访问的时候输出的，因此访问完所有的左子树，在第二次访问节点的时候，不能将节点输出并从栈内弹出，需要继续向右访问。因此我们无法判断节点是否已经访问过右子树，只有访问过右子树才可以从栈中弹出并输出。因此需要pLastVisit来标志上一个访问节点是不是来自于右子树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderIterative</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">	TreeNode* p = head;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		s.push(p);</span><br><span class="line">		p = p-&gt;left; <span class="comment">//刚开始一直遍历到左子树的最下端</span></span><br><span class="line">	&#125;</span><br><span class="line">	TreeNode* lastVisit = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">		p = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;right == <span class="literal">NULL</span> || p-&gt;right == lastVisit) &#123; <span class="comment">//如果右子树为空或者右子树已访问过，可以直接输出</span></span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			lastVisit = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;  <span class="comment">//说明右子树不为空且右子树没有被访问过，此时应该再把节点压栈，然后</span></span><br><span class="line">			s.push(p);</span><br><span class="line">			p = p-&gt;right;</span><br><span class="line">			<span class="keyword">while</span> (p) &#123;</span><br><span class="line">				s.push(p);</span><br><span class="line">				p = p-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后续遍历还有另外一种实现方法</span></span><br><span class="line"><span class="comment">//对于每一节点，首先将它入栈</span></span><br><span class="line"><span class="comment">//然后如果该节点没有左右孩子或者左右孩子都被访问过了，则输出</span></span><br><span class="line"><span class="comment">//否则将其右孩子，左孩子依次入栈</span></span><br><span class="line"><span class="comment">//这样可以保证每次取栈顶元素的时候，左孩子在右孩子之前被输出</span></span><br><span class="line"><span class="comment">//而且在根节点被输出前，左右孩子已经输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderIterative2</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">	TreeNode* p = head;</span><br><span class="line">	s.push(p);</span><br><span class="line">	TreeNode* lastVisit = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">		p = s.top();</span><br><span class="line">		s.pop();</span><br><span class="line">		<span class="keyword">if</span> ((p-&gt;left == <span class="literal">NULL</span> &amp;&amp; p-&gt;right == <span class="literal">NULL</span>) || (lastVisit &amp;&amp; (p-&gt;left == lastVisit || p-&gt;right == lastVisit))) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">			lastVisit = p;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			s.push(p);</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;right) s.push(p-&gt;right);</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;left) s.push(p-&gt;left);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历</span></span><br><span class="line"><span class="comment">//使用队列这种数据结构FIFO，就可以按照访问顺序打印节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layerReverse</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    TreeNode* p = head;</span><br><span class="line">    q.push(p);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        p = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p-&gt;value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left) q.push(p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right) q.push(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向Binary search tree中插入节点</span></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">insertToBSTRecursive</span><span class="params">(TreeNode* &amp;head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        TreeNode* newNode = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; head-&gt;value) &#123;</span><br><span class="line">            head-&gt;left = insertToBSTRecursive(head-&gt;left, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            head-&gt;right = insertToBSTRecursive(head-&gt;right, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertToBSTIterative</span><span class="params">(TreeNode* &amp;head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    TreeNode* newNode = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) &#123;head = newNode;&#125;</span><br><span class="line">    TreeNode* p = head;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(value &lt; p-&gt;value) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;left==<span class="literal">NULL</span>) &#123;</span><br><span class="line">                p-&gt;left = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;right==<span class="literal">NULL</span>) &#123;</span><br><span class="line">                p-&gt;right = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树插入节点的调整</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">singleLeftRotation</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">	TreeNode* newRoot = p-&gt;left;</span><br><span class="line">	p-&gt;left = newRoot-&gt;right;</span><br><span class="line">	newRoot-&gt;right = p;</span><br><span class="line">	p-&gt;height = max(getHeight(p-&gt;left), getHeight(p-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">	newRoot-&gt;height = max(getHeight(newRoot-&gt;left), p-&gt;height) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">singleRightRotation</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">	TreeNode* newRoot = p-&gt;right;</span><br><span class="line">	p-&gt;right = newRoot-&gt;left;</span><br><span class="line">	newRoot-&gt;left = p;</span><br><span class="line">	p-&gt;height = max(getHeight(p-&gt;left), getHeight(p-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">	newRoot-&gt;height = max(getHeight(newRoot-&gt;right), p-&gt;height) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">doubleLRRotation</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">	p-&gt;left = singleRightRotation(p-&gt;left);</span><br><span class="line">	<span class="keyword">return</span> singleLeftRotation(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">doubleRLRotation</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">	p-&gt;right = singleLeftRotation(p-&gt;right);</span><br><span class="line">	<span class="keyword">return</span> singleRightRotation(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">avlInsertion</span><span class="params">(TreeNode* &amp;head, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		head = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (value &lt; head-&gt;value) &#123;</span><br><span class="line">		head-&gt;left = avlInsertion(head-&gt;left, value);</span><br><span class="line">		<span class="keyword">if</span> (getHeight(head-&gt;left) - getHeight(head-&gt;right) == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (value &lt; head-&gt;left-&gt;value)</span><br><span class="line">				head = singleLeftRotation(head); <span class="comment">//左单旋</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				head = doubleLRRotation(head); <span class="comment">//左右双旋</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; head-&gt;value) &#123;</span><br><span class="line">		head-&gt;right = avlInsertion(head-&gt;right, value);</span><br><span class="line">		<span class="keyword">if</span> (getHeight(head-&gt;left) - getHeight(head-&gt;right) == <span class="number">-2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (value &gt; head-&gt;right-&gt;value)</span><br><span class="line">				head = singleRightRotation(head); <span class="comment">//右单旋</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				head = doubleRLRotation(head); <span class="comment">//右左双旋</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	head-&gt;height = max(getHeight(head-&gt;left), getHeight(head-&gt;right)) + <span class="number">1</span>; <span class="comment">//更新树高</span></span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h4><p>必须熟练掌握的算法：</p>
<ul>
<li>深度优先搜索(DFS) 相当于树的先序遍历</li>
<li>广度优先搜索(BFS) 相当于树的层序遍历</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图的两种遍历</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERTEX 8 <span class="comment">//节点的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EDGE 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> GraphNode &#123;</span><br><span class="line">	<span class="keyword">int</span> vertex;</span><br><span class="line">	GraphNode* next;</span><br><span class="line">	GraphNode(<span class="keyword">int</span> num = <span class="number">0</span>) :vertex(num), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isVisit[VERTEX]; <span class="comment">//标记每个节点是否被访问</span></span><br><span class="line">GraphNode graph[VERTEX];  <span class="comment">//头结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//建图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> Graph[VERTEX][<span class="number">2</span>], <span class="keyword">int</span> num)</span> </span>&#123; <span class="comment">//建立邻接表 num是边数</span></span><br><span class="line">	<span class="keyword">while</span> (num--) &#123;</span><br><span class="line">		<span class="keyword">int</span> from = Graph[num][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> to = Graph[num][<span class="number">1</span>];</span><br><span class="line">		GraphNode* newNode = <span class="keyword">new</span> GraphNode(to);</span><br><span class="line">		GraphNode* g = &amp;graph[from];</span><br><span class="line">		<span class="keyword">while</span> (g-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			g = g-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		g-&gt;next = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</span><br><span class="line">	isVisit[vertex] = <span class="literal">true</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vertex &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	GraphNode* p = &amp;graph[vertex];</span><br><span class="line">	p = p-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isVisit[p-&gt;vertex]) dfs(p-&gt;vertex); <span class="comment">//对于每一个node的邻居，没有访问过则访问</span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> vertex)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.push(vertex);</span><br><span class="line">	isVisit[vertex] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> vertex = q.front();</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vertex &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		GraphNode* p = &amp;graph[vertex];</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		<span class="keyword">while</span> (p) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!isVisit[p-&gt;vertex]) &#123;</span><br><span class="line">				q.push(p-&gt;vertex);</span><br><span class="line">				isVisit[p-&gt;vertex] = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> node[EDGE][<span class="number">2</span>] = &#123; &#123; <span class="number">0</span>, <span class="number">1</span> &#125;,&#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">2</span> &#125;,&#123; <span class="number">2</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">3</span> &#125;,&#123; <span class="number">3</span>, <span class="number">0</span> &#125;,</span><br><span class="line">	&#123; <span class="number">1</span>, <span class="number">4</span> &#125;,&#123; <span class="number">4</span>, <span class="number">1</span> &#125;,</span><br><span class="line">	&#123; <span class="number">1</span>, <span class="number">5</span> &#125;,&#123; <span class="number">5</span>, <span class="number">1</span> &#125;,</span><br><span class="line">	&#123; <span class="number">2</span>, <span class="number">6</span> &#125;,&#123; <span class="number">6</span>, <span class="number">2</span> &#125;,</span><br><span class="line">	&#123; <span class="number">3</span>, <span class="number">6</span> &#125;,&#123; <span class="number">6</span>, <span class="number">3</span> &#125;,</span><br><span class="line">	&#123; <span class="number">4</span>, <span class="number">7</span> &#125;,&#123; <span class="number">7</span>, <span class="number">4</span> &#125;,</span><br><span class="line">	&#123; <span class="number">5</span>, <span class="number">6</span> &#125;,&#123; <span class="number">6</span>, <span class="number">5</span> &#125;,</span><br><span class="line">	&#123; <span class="number">6</span>, <span class="number">7</span> &#125;,&#123; <span class="number">7</span>, <span class="number">6</span> &#125; &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VERTEX; i++) &#123; <span class="comment">//初始化</span></span><br><span class="line">		graph[i].vertex = i;</span><br><span class="line">		isVisit[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	createGraph(node, <span class="number">20</span>);</span><br><span class="line">	dfs(<span class="number">0</span>);  <span class="comment">//0,3,6,7,4,1,5,2</span></span><br><span class="line">	bfs(<span class="number">0</span>); <span class="comment">//0,3,2,1,6,5,4,7</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="4-1-Implement-a-function-to-check-if-a-tree-is-banlanced-For-the-purpose-of-this-question-a-balanced-tree-is-defined-to-be-a-tree-such-that-no-two-leaf-nodes-differ-in-distance-from-the-root-by-more-than-one"><a href="#4-1-Implement-a-function-to-check-if-a-tree-is-banlanced-For-the-purpose-of-this-question-a-balanced-tree-is-defined-to-be-a-tree-such-that-no-two-leaf-nodes-differ-in-distance-from-the-root-by-more-than-one" class="headerlink" title="4.1 Implement a function to check if a tree is banlanced. For the purpose of this question, a balanced tree is defined to be a tree such that no two leaf nodes differ in distance from the root by more than one"></a><strong>4.1 Implement a function to check if a tree is banlanced. For the purpose of this question, a balanced tree is defined to be a tree such that no two leaf nodes differ in distance from the root by more than one</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个树是否平衡</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	TreeNode(<span class="keyword">int</span> val = <span class="number">0</span>) : value(val), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="comment">// 一个树是平衡的需要满足两点：1. 左右子树都平衡 2. 左右子树的高度差不超过1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> diff = getHeight(root-&gt;left) - getHeight(root-&gt;right);</span><br><span class="line">	<span class="keyword">if</span> (diff &gt; <span class="number">1</span> || diff &lt; <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span>(isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  上述方法在算树高的时候，每个结点深度都被计算多次，不高效</span></span><br><span class="line"><span class="comment">// 如果在遍历到每个节点的时候，已经保存了它左右两边的高度差，就可以直接判断</span></span><br><span class="line"><span class="comment">// 采用后序遍历可以实现</span></span><br><span class="line"><span class="comment">// 因为后序遍历访问节点的时候，已经访问了它左右两边的节点，因此我们可以一边遍历一边判断是否平衡</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; depth)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		depth = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> left, right, diff;</span><br><span class="line">	<span class="keyword">if</span> (helper(root-&gt;left, left) &amp;&amp; helper(root-&gt;right, right)) &#123;</span><br><span class="line">		diff = left - right;</span><br><span class="line">		<span class="keyword">if</span> (diff &gt;= <span class="number">-1</span> &amp;&amp; diff &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			depth = <span class="built_in">std</span>::max(left, right) + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced2</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> depth;</span><br><span class="line">	<span class="keyword">return</span> helper(root, depth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 书上给出的方法：</span></span><br><span class="line"><span class="comment">// 如果一个数是平衡的，那么从根节点到叶子节点的最大距离与最小距离的差值不能超过1.</span></span><br><span class="line"><span class="comment">// 只考虑根节点的距离差异，是因为根节点的距离差异是所有节点距离差异可能的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">std</span>::min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (maxDepth(root) - minDepth(root) &lt;= <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-Given-a-directed-graph-design-an-algorithm-to-find-out-whether-there-is-a-route-between-two-nodes"><a href="#4-2-Given-a-directed-graph-design-an-algorithm-to-find-out-whether-there-is-a-route-between-two-nodes" class="headerlink" title="4.2 Given a directed graph, design an algorithm to find out whether there is a route between two nodes"></a><strong>4.2 Given a directed graph, design an algorithm to find out whether there is a route between two nodes</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VERTEX 10</span></span><br><span class="line"><span class="comment">// 给两个节点，判断它们之间是否有路径</span></span><br><span class="line"><span class="comment">// 考查的是图的遍历，可以用BFS或者DFS</span></span><br><span class="line"><span class="keyword">struct</span> GraphNode &#123;</span><br><span class="line">	<span class="keyword">int</span> vertex;</span><br><span class="line">	GraphNode* next;</span><br><span class="line">	GraphNode(<span class="keyword">int</span> num = <span class="number">0</span>) :vertex(num), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isVisit[VERTEX];</span><br><span class="line">GraphNode graph[VERTEX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasRoute</span><span class="params">(GraphNode* from, GraphNode* to)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (from-&gt;vertex == to-&gt;vertex) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	isVisit[from-&gt;vertex] = <span class="literal">true</span>;</span><br><span class="line">	GraphNode* node = &amp;graph[from-&gt;vertex];</span><br><span class="line">	node = node-&gt;next;</span><br><span class="line">	GraphNode* flag = node; <span class="comment">//避免有环的情况</span></span><br><span class="line">	<span class="keyword">while</span> (node) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!isVisit[node-&gt;vertex]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (hasRoute(node, to)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node = node-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (node == flag) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-Given-a-sorted-increasing-order-array-write-an-algorithm-to-create-a-binary-tree-with-minumal-height"><a href="#4-3-Given-a-sorted-increasing-order-array-write-an-algorithm-to-create-a-binary-tree-with-minumal-height" class="headerlink" title="4.3 Given a sorted(increasing order) array, write an algorithm to create a binary tree with minumal height"></a><strong>4.3 Given a sorted(increasing order) array, write an algorithm to create a binary tree with minumal height</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过一个有序数组构建一个高度最小的树</span></span><br><span class="line"><span class="comment">// 当每个节点左右子树的高度相等时，这棵树是最小的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	TreeNode* left;</span><br><span class="line">	TreeNode* right;</span><br><span class="line">	TreeNode(<span class="keyword">int</span> val = <span class="number">0</span>) : value(val), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">    TreeNode* newNode = <span class="keyword">new</span> TreeNode(<span class="built_in">array</span>[mid]);</span><br><span class="line">    newNode-&gt;left = helper(<span class="built_in">array</span>, left, mid<span class="number">-1</span>);</span><br><span class="line">    newNode-&gt;right = helper(<span class="built_in">array</span>, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">createMinBST</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span> || <span class="built_in">array</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="built_in">array</span>, <span class="number">0</span>, length<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/25/intership/" itemprop="url">
                  找实习的那些日子    --善待挫折
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-25T23:37:12+08:00" content="2016-05-25">
              2016-05-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/实习/" itemprop="url" rel="index">
                    <span itemprop="name">实习</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/实习/经验/" itemprop="url" rel="index">
                    <span itemprop="name">经验</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/25/intership/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/25/intership/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转眼，已近快五月底了。距离自己3月初投出的第一封简历开始，已经接近3个月了。回首过往，这90天日日夜夜，其中的辛酸与喜悦，也许只有自己才能体会到。我并不是什么计算机大牛，开始转行计算机也才只有半年的时间，并没有可以拿的出手的相关项目，以至于刚开始的时候看着自己的简历，连过简历关的自信都没有。最终能拿到Nvidia的offer，并进入了百度，阿里和网易游戏的终面，靠的算是自己的努力和幸运吧。</p>
<p>2月底的时候，同学来问我要不要找暑期实习。我当时还跟他说，我没这个打算，暑假要刷题。后来他来我实验室让我看了一下网易游戏的招聘主页，说他投了XX岗位。当时我的心里痒痒的，也想去试一下，正好手头有份简历，索性就填了一下申请资料。投简历是会上瘾的，没过几天，3月1号，阿里校招正式开始，我又完善了一下个人简历，投了阿里的C++开发岗位。因为没有人内推，按照它网站上的招聘公告，要等到4月中统一笔试面试，谁知道投简历的第二天，就接到了来自北京的电话。</p>
<h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><p>对于阿里，我只想说：我待阿里如初恋，阿里待我当备胎</p>
<p>阿里是我人生中第一次面试技术岗的公司，所以对于阿里还是有很深的感情的。投了阿里不到一个星期，中午我照常回宿舍睡觉，然后收到了一条短信，大概就是说他是阿里的谁谁谁，给我打电话打不通，希望我回拨回去。我当时立马从宿舍床上跳了起来，那个激动啊！直接回拨了他的电话，对方竟然是个妹纸！然后就问我现在方不方便面试。我说好。处女面是完全零准备的，当时也是有一种初生牛犊不怕虎的感觉，现在想想真是图样图森破。</p>
<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>刚开始叫我自我介绍一下，由于之前没准备过，所以我就磕磕碰碰的说了自己的名字专业什么的。结果妹纸人很好，说我不用紧张，只是彼此聊聊天，之后我就慢慢放轻松了。</p>
<p>一面主要就是问简历上的一个项目。当时我在做的是基于机器学习的语音转换，所以就跟妹纸侃了侃我用到的机器学习算法。跟她介绍的时候我还在想这是个妹纸，应该是HR吧，说多了她也可能听不懂。谁知道这是轮技术面，妹纸是专业的。她追问了我很多很细节的东西，比如说我为什么选择这个模型而不选择另一个模型，参数是怎么设置的，真是遇上行家了。好在我在做项目的时候也看了很多paper，所以也能说出个大概所以然来。最后，妹纸说要问我一道数据结构题：arraylist和linkedlist的区别。这也太简单了吧！我心里暗喜，说了一下内存连续性和一些操作的复杂度比较，妹纸挺满意的。结束的时候，我问她们Team是做什么的，她说是投放广告相关的。后来我问我一个即将入职阿里的同学，他说90%是阿里妈妈组的，是阿里的核心部门，感觉不错。我就更开心了，一定要好好把握。</p>
<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>阿里一面结束后，我才意识到，面试机会在我投简历的那一刻随时可能到来，我不能再消极回避，要开始准备了。既然投了简历，那就应该争取通过面试拿到offer。</p>
<p>阿里一面结束的两个小时内，我收到阿里了二面的邮件通知，我有三天的时间准备。那三天，我好好准备了自我介绍，梳理了自己做过的相关项目，温习了一些机器学习的知识，刷了一些经典的算法题，焦急地等着二面的到来。在这之前，我找人帮我内推了腾讯的TST，然后面阿里的前一天下午，腾讯的面试官加我QQ，跟我约面试。当时也是激动的不行，曾经想都不敢想的BAT，现在竟然都能给我面试机会，我简直不敢相信。腾讯的面试正好和阿里面试约到了同一天，排在阿里面试的后面。结果当天，到了约定时间一直没有接到阿里的面试电话，我感觉自己可能被默拒了，好伤心，后来都快到7点了，一面的面试官打电话过来了，说她没跟二面面试官沟通好所以很抱歉，然后又跟我约了新的时间。</p>
<p>二面是个小哥，声音很好听。刚开始也是聊项目，小哥表示听不懂我做的项目，说这样吧，给我了一个情景，让我建一个模型。天哪噜，这问题也太开放了吧。中间小哥有问到我的模型过拟合了怎么办，这个问题我正好准备过，我就说了教科书上的答案，结果小哥好像很不满意，表示他们实际中并不是这么解决的。对于小哥问的很多问题，我都很难理解他的意思，他也表示他没有听到令自己满意的答案，所以整个面试过程中我是崩溃的。后来快结束的时候，我问他，我是不是表现的很差劲，结果小哥给了我很多建议，关于想问题的角度和方向，以及回答问题的技巧之类的。虽然我答得不是很好，但是他不这么就算了，给了我很多指导，让我觉得很感动。最后，他想问我一道算法题，问我用什么语言。我说C++，结果他沉默了10s中，说自己不会C++。然后就不问了。二面结束后，我觉得应该是挂了，面试的问题太开放，自己思考的不够全面回答的不好。谁知道一周后，我接到了三面的电话。</p>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><p>三面应该是部门的主管，听声音不是很年轻，说话也比较快，没什么感情色彩。一开始问了我几个HR应该问的问题，什么我怎么评价我前两次面试的表现，哪一点表现的最不好，如果给你一个重新回答的机会，你会怎么回答之类这样的问题，应该是想看我的反应能力和总结能力吧。然后他说开始正式面试。总共是问了3道算法题，现在只能回想到其中一道了，是对于100万个数怎么找到中位数的。3道算法我都还答得可以，从暴力解决一步步谈到了最优解，复杂度也能分析，我根据他也挺满意的。结束的时候我向他确认他们组是不是做广告投放的，结果他说我最终的BU要由阿里集团统一决定。后来我听别人说应该是自己的面试总成绩不够好，被放到了备胎池，才说要由集团统一决定。</p>
<h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><p>四面是HR面，是杭州打过来的。那天是周末，阿里还在上班，真是敬业啊。HR感觉不太友善，气汹汹的，不知道是不是因为周末上班心情不爽，然后我就被各种刁难压力面。比如说他会说他觉得我做的这个项目没什么用啊，让我自我介绍然后他说你这也算是自我介绍，说了像没说一样。江湖传说中的阿里终极大Boss，有一票否决权的HR，终于见识了。面完感觉自己很危险，很有可能功亏一篑。我不停地刷面试状态，结果城市变灰了，状态一直在面试中，有人说城市变灰是挂了的意思，我也是忧心忡忡的。后来知道才知道没变灰才是挂了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从投简历到面完HR大概用了两周多的时间。面完HR是3月中下旬，后来就是漫长的等待，这中间有小伙伴被拒绝了，有小伙伴收到了offer，而我是万年不变的“面试中”。这样一直被拖着，我也不能参加阿里统一的校招了，阿里客服说安心等结果就好了，最迟会在5月底发出来。也有人说要是拒绝的话早就拒绝了，不确定的话可能评级是A+，BU做不了主要给集团统一做主，然后我因为不是内推也不应该提前收到offer之类的，所以直到现在我还是“面试中”的状态。</p>
<p>总结起来就是，阿里的校招要早点投简历，一定要找人内推，这样可以查到自己的评级还有进展，不像我这种情况进行到哪一步都不知道。然后阿里比较注重技术和算法，注重一个人解决问题的能力，而不是像腾讯那样更加注重一个人的经验。所以，阿里的文化还是比较契合我的价值观的，除了“拥抱变化”。</p>
<h2 id="网易游戏"><a href="#网易游戏" class="headerlink" title="网易游戏"></a>网易游戏</h2><p>虽然网易游戏不是三大互联网巨头之一，但是近几年做游戏越来越火使得它给硕士生开出的工资达到了30万，超过了BAT给出的工资，因此也是很多人竞争。另外听说它的食堂是国内最好的，水果下午茶无限量供应，对于吃货的我，也免不了吃的诱惑啊。</p>
<h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><p>网易游戏我报的是游戏开发，这个岗位对学校有要求，然后必须是硕士。网易游戏允许内推，但是内推的话不能免笔试，只能免筛简历关。我没有人内推，过了简历关的筛选，然后就是笔试。笔试是Online Judge, 3道算法题，虽然没有到ACM那种难度，但是每个题目都长的很，光题目就很难理解，对于我这种没有ACM竞赛经验的人，完全无法在一个半钟做出来一题啊。找了男票助攻，可是他很久没写过代码了，写起来也是很多bug，最后是得到了90分（满分300分）。笔试完我就释怀了，对于这种有很多清北大牛来竞争的公司，我等渣渣还是哪凉快哪呆着吧。结果一周内，我竟然收到了它的二面通知，而且它短信里说，由于笔试表现好所以只需要一次面试，希望又燃起了!</p>
<h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><p>二面是电话面试，面试官准时打来了。网易是考C++考的最多的公司，可能做游戏需要很懂C++吧。问了一些C++11的特性，static关键字在C/C++中不同的作用，虚函数表的实现机制等等。还问了操作系统，网络之类的知识，都是比较经典的，提前准备就都没问题。然后问了两个比较难的算法，我没有答出最优解，问为会不会lua语言，还出了一个游戏登陆ip相关的问题，我都不太记得了。我对自己的整体表现能给70分吧，结果等了一周收到了拒信。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>网易游戏是我觉得校招做的比较好的公司，筛简历筛了很多人，所以只需要两轮面试，不像其他公司要4,5轮，这样缩短了面试周期，面试者也不用那么累。不用HR面，完全用技术来说话。通过或者不通过都会有短信通知，不像其他公司没有通知就是没有通过，让面试者一直处于期待中的状态。只是自己的水平还不够，最终没有拿到offer，所以也是当做了一次宝贵的面试经历。</p>
<h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><p>对于百度，最近也是各种负面新闻，卖贴吧，卖假广告等，以至于有人说，百度现在也就是个外卖公司了，只有点外卖才用百度。但是毕竟是BAT之首，所以当然也去投个简历看看。百度的校招开始的很晚，开放投简历是4月中，5月初才笔试面试，所以很多人都拿到了阿里和腾讯的offer也就不去百度了。我投的是深圳的软开，职位描述那里写的只招5个人，觉得可能没什么希望。结果笔试的时候我自己答得很满意，选择题有80%把握，然后3道算法题全部AC了，觉得肯定会有面试机会的吧。结果笔试完就了无音讯了。有可能是招满了，再有可能笔试完根本就没有面试，就是不想招人了，因为网上没有人说拿到了百度深圳的面试机会的。我有个同学也是报的深圳的其他岗位，结果笔试过了很久才接到电话问他愿不愿意去北京，如果愿意就安排面试，不愿意就没机会了。</p>
<p>我实验室有个师姐在群里转了一个消息，是百度地图招实习生的。我联系了发布这条消息的人，让他内推我。于是就有了接下来百度的三次面试机会。</p>
<h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><p>一面是电话面，是一个小哥。他的问题涵盖了计算机相关的所有领域，数据库，网络，操作系统，算法，编程语言等等，问的不深但是很全面。由于我在面百度前已经有了很多经验了，很多题目都被面过，所以也答得挺好的。可见百度对于一个人的计算机基础比较重视。</p>
<h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><p>二面也是电话面，又是一个妹纸。二面主要问项目，她对我简历上用hadoop计算twitter tag similarity的项目比较感兴趣，我仔细跟她讲了讲每一步的map和reduce过程。然后她让我用hadoop完成大数据的排序，顺便问了怎么解决数据倾斜问题，节点运行的时候失败了是怎么解决的。我对hadoop了解不深，所以答得很浅显。最后她说他们Team有百度地图上面来自用户的海量数据，需要对数据进行处理分析，会用到MongDB，问如果给我一周的时间我能不能学会之类的。这样的问题让我觉得自己通过的可能性很大。最后她问我什么时候能来，能实习几个月。我不善于骗人，就说了5月底才能来，实习2个多月这样子。后来收到了拒信以后我问她原因她说，我表现的很好，但是实习时间是硬伤，她们招实习生至少6个月。</p>
<h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><p>三面面试官要求我去深圳现场面，因为当时在赶InterSpeech的论文很忙，我就说只能过段时间再去。结果他们可能需要和其他面试者比较吧，需要面试进程快一点，就同意改成了视频面试。面试前我才发现，面试我的这个经理就是内推我的这个人，当时觉得应该就没问题了，他和我师姐是同学，肯定不会刁难我的。三面是非技术面，就是聊一聊面试时间，聊一聊我的性格。记忆犹新的一个问题是我在大学的时候，哪件事让我觉得很受挫折。我想了很久告诉他，没有。不知道这样回答好不好。还记得他问我最近在看什么书，我说CSAPP，结果他让我说一下每一章的目录内容，我不太记得了。聊了大概半小时吧，他总共问了我3次能实习多久，问我这么早回学校干什么。现在想想自己真是笨啊，明显他们比较关心实习时间，自己怎么就不开窍呢，还一口咬定自己2个月后就要回学校，唉。</p>
<h3 id="校招一面"><a href="#校招一面" class="headerlink" title="校招一面"></a>校招一面</h3><p>拿到了百度校招的笔试机会，感觉自己做的不错但是笔试完就杳无音序了。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>百度的面试更注重考计算机基础，算法考的也不深。但是一定要求实习生能实习半年以上的，所以我如果有充分的实习时间应该是能拿到百度的offer的。而且MongDB我也很感兴趣，二面结束后我也去自学了一些Nosql，可惜用不上了。</p>
<h2 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><p>腾讯，一直是自己最想去的地方。不仅是因为离家近，而且公司自由开放的氛围也是自己向往的。对腾讯的面试准备的最多，经历也最坎坷。</p>
<h3 id="内推一面"><a href="#内推一面" class="headerlink" title="内推一面"></a>内推一面</h3><p>身边的人去的最多的就是腾讯，反而没有人去百度和阿里的，所以给我的错觉就是腾讯可能会好近一点吧。找了两个同学，分别内推了QQ邮箱和TST，后台开发岗。推QQ邮箱的一直没有消息，推TST的大概一周后安排了视频面试，对方是手机QQ组的。</p>
<p>这是印象最深的一次面试。对方是个工程师，大概30出头，比较和蔼。先是给我发来了一套卷子，给我半个小时让我做。面腾讯之前只面过阿里，所以当时也没有什么面试经验，看到卷子的时候我就懵了。天哪，这都是什么呀。问的好详细，大小端序，内存分配，结构体，虚函数，三次握手，shell编程，位图，百万数据找最大数等。当时看来觉得好难，可是现在看起来觉得并没有那么难，还是准备不充足的问题啊。半个小时候，我把卷子发给他，然后我们一道道题探讨，中间又引申出来其他的问题，大概讨论了一个小时。结束后，我问一个CS科班出身的同学，跟他吐槽腾讯的问题这么变态，然后他告诉我这些题都是很经典的面试题，还有书专门总结了这些问题的，叫做程序员面试宝典，建议我准备面试前读一读那本书。那时我才知道，原来还有经典面试题这种东西，还是我图样图森破了。</p>
<p>一面结束后，虽然题目写的不好，但是在和面试官讨论的过程表现还不错，隐隐感觉自己是有希望的。其实现在看来，这些问题属于程序员本应该知道的常识性问题，这些题目都答不好，肯定是要被刷的。所以这次面试以后，我去恶补了计算机网络，数据库，操作系统的基础知识，然后之后的面试这些问题就得心应手了。</p>
<h3 id="校招一面-1"><a href="#校招一面-1" class="headerlink" title="校招一面"></a>校招一面</h3><p>大概是4月中上的时候，收到了腾讯校招的面试短信。当时距离内推一面已经过去了半个多月，因此内推的那次面试也是挂了。 面试安排在大学城的一家酒店。这是我第一次面对面的面试。具体的面经可以看我发表在大街网上的文章：<a href="http://www.nowcoder.com/discuss/4631?type=0&amp;order=4&amp;pos=28&amp;page=3" target="_blank" rel="external">腾讯广州后台开发一面</a></p>
<p>面试总共进行了约两个小时，前半个小时写一个OOD的代码，然后后一个小时就问各种问题，最后半个小时就跟讨论一些我的问题。走出房间的时候我都快哭了，真的太难了，我觉得如果是放在现在再来问我这些问题，我答得很可能好不到哪里去。因为有些知识，你只有做过项目，或者通过实习经历了解过企业是怎么实现的，才能答得好。而我们平时总是在学校，做的项目偏向算法，基本没有工程经验。我也跟面试官探讨过这个问题，我认为面试出这些题目很没有意思，因为这些知识就是你知道就是知道，不知道的话你可能看一眼查查资料很快就知道了。然后面试官表示他们会希望面试者有一些非学校的工程经验，需要自己做一些开源找一点项目来做。原来腾讯就是这么面试人的，我很失望。</p>
<h3 id="深圳霸面1"><a href="#深圳霸面1" class="headerlink" title="深圳霸面1"></a>深圳霸面1</h3><p>在广州场的时候被拒的经历，让我一直很不甘心。我觉得自己的实力至少是能到二面的，可能是运气也不太好，遇到这么样一个面试官，和一般的面试官面试出的题目难度相差太多。咨询了腾讯的同学后，我决定去深圳场霸面。早就听说腾讯允许霸面，所以也算是回家，顺便去碰碰运气。</p>
<p>那天早上九点就到了深圳大族激光大厦，一直等到了下午7点钟，悻悻而归。现场霸面的人很多，而真正给了面试机会的寥寥无几。很多都是像我这样子在广州场挂了的，不甘心再来深圳霸面。因为是霸面，所以面试官的要求也高了很多，除非有特别出彩的经历，所以基本霸面是没有机会的。霸面的话就直接交简历给HR，然后就是漫长的等待被翻牌。我是一直没有被翻牌的，之间有零散的几个面试官过来看简历，也没有挑中我，很沮丧。可是后来我渐渐明白了，面试其实是一个很看运气，看眼缘的过程。有的时候你没有被面试官看上，并不是你的能力不够优秀，而是你的技术栈和他们想招的人不吻合，或者他们已经招满人了，或者他今天就是心情不好。所以还是要多投简历，不要沉浸在一次被拒绝的悲伤中，要赶快收拾好心情勇敢面对。我第一次收到百度的拒信的时候就伤心了很久，后来也是逐渐意识到面试的随机性，也就释怀了。当我真正释怀的时候，也是水平和能力发挥出来的时候。</p>
<p>晚上，男票过来了，叫了一个在腾讯上班的同学，我们一起吃烤鱼。然后他那个同学就说霸面不是应该在楼下等的，应该是找机会上楼直接将自己推销给面试官。他鼓励我明天再来试试，他可以把工卡给我，带我混进去。我想了想，有点怂，再加上受打击了，就谢过了他的好意。</p>
<h3 id="深圳霸面2"><a href="#深圳霸面2" class="headerlink" title="深圳霸面2"></a>深圳霸面2</h3><p>第二天起床，还是有点不开心，觉得自己不应该就这么放弃了。既然自己这么想去腾讯，也回来了深圳，如果有机会，为何不再去争取下呢？后来我问了男票，他也鼓励我去。所以我就联系了昨晚那个腾讯的同学，约好他下午带我混进去。</p>
<p>他带我混进去后，把他的工卡给了我，这个工卡可以去任何地方，之后就靠我自己了。第一次做偷偷摸摸的事情，我还是很忐忑的。我去了一些楼层，没有发现有面试迹象，后来发现HR都把面试者带到了7楼，所以我也去了7楼。7楼有个平台提供咖啡，然后左右通道都有很多小房间，我进去后就找了个位置坐下来，旁边有两个HR在坐着，周围也有一些看起来是来面试的同学。我很紧张，不知道自己接下来要去哪里，在那里坐了好久。然后有个男生来搭讪，相互聊了一下发现他也是偷偷溜进来的，在厕所躲了半个小时才从楼梯爬上来的。他想面的是市场岗。然后我们两个就坐在一起，等看看有没有其他同学来面试的，打探出面试官的房间之类的。中间我装作上厕所走进了左边的通道，转悠了一圈发现全部是产品岗，就出来了。然后我跟那个男生说，我们这样等下去不行，看能不能跟那个HR说说我们的情况，给我们一次机会。然后那个男生就去说了，HR就说不行。没过一会，就有个另外一个HR气冲冲的走过来，要赶他下去，还威胁他要叫保安之类的。那个男生被带走后，我就更紧张了，感觉自己也很快就要被发现的样子。我想了想，鼓足了勇气，走向了另一边走廊，当时想的就是遇到个面试官就冲进去给他看简历。我发现了一个面试官，然后里面有在面试的同学，我就先进了厕所。然后我出来的时候，发现里面就只有面试官一个人了。我冲进去，解释了一下自己的情况，问他能不能给我个机会。他刚开始让我去找HR，后来我说HR会把我赶走的，他就问我面的是技术岗吗？我说是。然后他就问我要了简历。他看了一会，从后面就传出了“什么情况”的声音，原来是HR带即将面试的同学过来了。面试官把简历还给我，说跟他的要求不符。然后我很害怕，拿了简历就快速离开了，生怕被HR抓住。其实还是有机会的，如果HR没出现的话。这也从侧面说明了腾讯真的是跟我无缘了，几次运气都不太好。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>经历了这么多坎坷的面试过程，虽然最后的结果是失败了，但是第一次霸面，第一次主动向别人推向自己，我也是克服了很大的心里障碍，锻炼了胆量。腾讯是一个很实际的公司，也许培养一个新人的代价太大，所以希望招进来的人进来就能干活。腾讯面试结束后，此时我已经是比较绝望了，收到了百度的拒信，阿里被当做备胎了，腾讯又注定挂了。之前自信满满的认为自己至少BAT能拿到一个offer，结果现在一个都没有。因为之前一心想去BAT也没有投其他的公司，而现在再投其他的公司也晚了。对于自己这种非科班出身，又没有ACM或者实习经历的，刚开始的定位应该是二类公司，比如说网易，华为，蘑菇街之类的。是我高估了自己的能力了。</p>
<h2 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h2><p>一面是笔试，投的是广州的软开。也是做了笔试题后就无消息了。有消息的是北京那边的岗位，广州的一直都无动静。前段时间京东又说要补招，所以就有个笑话是说，京东为什么要补招呢？因为他根本就没有招啊。</p>
<h2 id="优酷土豆"><a href="#优酷土豆" class="headerlink" title="优酷土豆"></a>优酷土豆</h2><p>投的广州的软开，也是做了笔试后就没消息了。</p>
<h2 id="大疆"><a href="#大疆" class="headerlink" title="大疆"></a>大疆</h2><p>很无语。先是做了90分的卷子，都是什么题呢？举个例子：假设你要买一部iphone6，请问一下哪一个是你将要做的？A. 查Iphone的优点 B. 查Iphone6的优点 C.查同等价位其他手机的优点 D.查同等价位其他手机的缺点。做完了卷子然后说如果分数通过了就会有第二套卷子，结果我没通过。至今觉得这面人的流程真傻逼。</p>
<h2 id="IBM蓝色之路"><a href="#IBM蓝色之路" class="headerlink" title="IBM蓝色之路"></a>IBM蓝色之路</h2><p>IBM是我觉得最无语的一个公司。首先我在官网投的是GBS的IT Specialist,结果来面试我的是一个做咨询的部门，面试官全部不懂技术，而招的岗位有非技术岗和技术岗，并且两个的职位要求都要很懂计算机。一面是笔试，除了第一道问IBM现任CEO是谁的，全部是计算机的题。二面是群面，是的，你没听错，技术岗还要搞群面！面什么呢？给一份几页的谈判资料，然后给半个小时时间学习，然后分组讨论，最后分成供应商和客户两组进行模拟谈判。完全一点计算机技术都没有好嘛。感觉笔试也只是刷刷面试者背景的吧。</p>
<h2 id="中国移动"><a href="#中国移动" class="headerlink" title="中国移动"></a>中国移动</h2><p>所有投中国移动岗位的人，无论是技术还是非技术，都统一参加了一个行测的考试，然后现在还没有后续进展。</p>
<h2 id="Nvidia"><a href="#Nvidia" class="headerlink" title="Nvidia"></a>Nvidia</h2><p>虽然N家主要是做硬件的，但是我去的这个组是做软件的，而且Team整体的氛围也很不错，我最后能拿到N家的offer也纯属巧合。我先是看到他们放在网上的招聘信息，是全英文的，要英文简历，而且只招一个人。当时手头就只有中文的简历，也没多想，就投了个中文简历过去了。然后过了2天吧，就有上海的来电话，说要约phone interview.</p>
<h3 id="Phone-Interview"><a href="#Phone-Interview" class="headerlink" title="Phone Interview"></a>Phone Interview</h3><p>这种国际企业的好处就是，面试流程都是按照美国那边的套路，可以完全为我之后找工作练手。先是一轮phone interview, 如果他们觉得你还OK了，就会约你去他们办公室On-site.On-site一般有3轮，我去的时候是4轮，也是累的要死。电话面试就一直在聊项目，他对我的hadoop，spark的项目比较感兴趣，问了很多。然后问了简单的一道JAVA和Python的问题。很多东西他问我，我都说不知道，所以面试完，我自我感觉是不好的。因为的确很多东西都不太知道。谁知道第二天又有上海那边的人打电话过来，说还挺满意的，要约我去他们深圳的办公室。</p>
<h3 id="On-site"><a href="#On-site" class="headerlink" title="On-site"></a>On-site</h3><p>4轮面试，前三轮是工程师面，最后一个是Manager来面。除了最后一轮聊天式的面试，其他三轮都是技术面。第一轮面试官比较年轻，和我年龄相仿，问了我Hadoop的项目。然后就让我手写代码。题目是一堆连续的数中找缺的一个数，两个数和三个数。我分别说了不同的解法，除了在找三个数那里卡了一下，其他的还算勉强说的出来。结束的时候面试官说很少面试者能说出我说的最优的那个算法的，说我算法还是可以的。第二轮On-site也是开始问问项目，又是手写代码，题目是找到整数拼接最大的组合。我之前刷过一个类似的，于是也能给出O(NlogN)的解法，他也比较满意。第三轮的工程师看起来年龄比较大，他问我的算法题是找最大连续子序列和。在我写出了动态规划的解法后，他又要求我写一个递归的写法。我也是写出来了。第四轮就聊聊未来规划，然后Manger聊了很多他们组在做的项目，也问了一下我想做哪个项目。Manger人很和蔼，感觉蛮好的。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>虽然Nvidia不是传统的互联网公司，但是是硅谷上市公司，也很有名气，在里面也应该能学到一些比较好习惯。而且做的项目我也很喜欢，项目组的人也很和蔼，工作时间是弹性制的，很多规矩都是效仿美国那边的，所以这个实习经历还是对我以后在美国找工作比较有帮助的。关键是，能学到东西，开心就好啦。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>投了一直无消息的还有：金山，小米，搜狗，亚马逊，SAP，豆瓣， 招商银行等。</p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>这三个月，我不仅要上课做项目，还有做毕业设计发论文，还要准备实习面试，还要准备出国前的材料办签证，所以时间也是很紧张的，基本没怎么休息过。现在放假了，实习也定了下来，再回首来看这三个月的成长，倍感欣慰。如果没有这些宝贵的面试经验，我就一直不会知道自己需要加强的地方，也不会确定自己未来努力的方向。面试不仅是为了拿到一个offer，更重要的是它能帮你成长。最后要谢谢一直在背后支持我的计算机大神，我的男票。要不是他带我入坑计算机，我可能现在还不知道自己将来要做什么呢。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/21/C3/" itemprop="url">
                  Ctci 读书笔记（四）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-21T13:18:31+08:00" content="2016-05-21">
              2016-05-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/面试/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/21/C3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/21/C3/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Chapter-3-Stacks-and-Queues"><a href="#Chapter-3-Stacks-and-Queues" class="headerlink" title="Chapter 3 Stacks and Queues"></a>Chapter 3 Stacks and Queues</h2><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Stack是LIFO数据结构<br>C++ STL中的stack和queue叫适配器（containers adaptors），而不叫容器，是对容器的再封装。<br>Underlying containers 可以是vector, deque和 list。By default, 底层容器是deque（封闭头部）<br>一般使用deque和list，而不使用vector，原因是vector扩容（reallocate）耗时<br>PS. deque是双端队列，可以提供随机访问，支持首尾的快速增删。看起来很像vector，区别是deque提供了首的快速增删，并且deque在内存中的存储是不连续的，因此deque在某些情况下比vector更高效（针对元素多，扩容很频繁的情况）<br>list是双向链表，支持任意位置的快速增删（前提是有一个iterator指向待删除的地方，并且返回的iterator仍然有效），但是不支持随机访问，在内存中的存取也是不连续的。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Constructor</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; first; <span class="comment">//empty stack</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; second; <span class="comment">//empty stack using vector</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Insert element </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        first.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Access element </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pop out element: "</span> &lt;&lt; first.top() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Pop element </span></span><br><span class="line">    first.pop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Size </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以自己用数组或者链表模拟一个stack，实现基本的插入和删除</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct</span> Node &#123;</span><br><span class="line">	Node* next;</span><br><span class="line">	T data;</span><br><span class="line">	Node(T val) :data(val), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组模拟</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Stack &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T s[size];</span><br><span class="line">	<span class="keyword">int</span> pointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stack() &#123;</span><br><span class="line">		pointer = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer &lt;= size) &#123;</span><br><span class="line">			s[pointer++] = item;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Not enough memory"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer &gt; <span class="number">0</span>)  --pointer;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No element inside"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer &gt; <span class="number">0</span>) <span class="keyword">return</span> s[pointer<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No element inside"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//用链表模拟</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Stack2 &#123;</span><br><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">	Node&lt;T&gt;* pointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Stack2() &#123;</span><br><span class="line">		pointer = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">		Node&lt;T&gt;* newNode = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line">		newNode-&gt;next = pointer;</span><br><span class="line">		pointer = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			Node&lt;T&gt;* pdelete = pointer;</span><br><span class="line">			pointer = pointer-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> pdelete;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No element inside"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pointer != <span class="literal">NULL</span>) <span class="keyword">return</span> pointer-&gt;data;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No element inside"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">	s.push(<span class="number">2</span>);</span><br><span class="line">	s.push(<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	s.pop();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>Queue是FIFO结构<br>C++ STL中的queue叫适配器（containers adaptors），而不叫容器，是对容器的再封装。<br>Underlying containers 可以是deque和 list。By default, 底层容器是deque</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Constructor</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; first; <span class="comment">//empty stack</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &gt; second; <span class="comment">//empty queue using list</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Insert element at the back</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        first.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Access next element (oldest)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Pop out element: "</span> &lt;&lt; first.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Pop next element (oldest)</span></span><br><span class="line">    first.pop();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Access last element (newest)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Newest element: "</span> &lt;&lt; first.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Size </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; first.size();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>可以自己用链表模拟一个queue，实现基本的插入和删除。对于从一头插入，另一头删除的数据结构用数组实现不高效，因此就不使用数组实现了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">struct</span> Node &#123;</span><br><span class="line">	Node* next;</span><br><span class="line">	T data;</span><br><span class="line">	Node(T val) :data(val), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class</span> Queue &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Node&lt;T&gt;* head;</span><br><span class="line">	Node&lt;T&gt;* last;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Queue() :head(<span class="literal">NULL</span>), last(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">		Node&lt;T&gt;* newNode = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			head = last = newNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			last-&gt;next = newNode;</span><br><span class="line">			last = last-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> head-&gt;data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No element inside"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			Node&lt;T&gt;* pdelete = head;</span><br><span class="line">			head = head-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> pdelete;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No element inside"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (last != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> last-&gt;data;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No element inside"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">	q.push(<span class="number">1</span>);</span><br><span class="line">	q.push(<span class="number">2</span>);</span><br><span class="line">	q.push(<span class="number">3</span>);</span><br><span class="line">	q.push(<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	q.pop();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q.front() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; q.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><h4 id="3-1-Describe-how-could-you-use-a-single-array-to-implement-three-stacks"><a href="#3-1-Describe-how-could-you-use-a-single-array-to-implement-three-stacks" class="headerlink" title="3.1 Describe how could you use a single array to implement three stacks"></a><strong>3.1 Describe how could you use a single array to implement three stacks</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用一个数组来实现三个栈</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解法1：</span></span><br><span class="line"><span class="comment">//将数组分成3等分，对于每一个栈维护一个栈顶指针</span></span><br><span class="line"><span class="keyword">class</span> ArrayToThreeStack &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> stackNum = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> buffer[size * stackNum];</span><br><span class="line">	<span class="keyword">int</span> pointer[stackNum];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ArrayToThreeStack() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(buffer, <span class="number">0</span>, size*stackNum*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">		<span class="built_in">memset</span>(pointer, <span class="number">0</span>, stackNum*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (pointer[stackId] == <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (pointer[stackId] == size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackId, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isFull(stackId)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> stackId;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> index = stackId*size + pointer[stackId];</span><br><span class="line">				buffer[index] = value;</span><br><span class="line">				pointer[stackId]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to pop cause stack"</span> &lt;&lt; i &lt;&lt; <span class="string">" is empty"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isEmpty(stackId)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> stackId;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> index = stackId*size + pointer[stackId];</span><br><span class="line">				buffer[index - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">				pointer[stackId]--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to pop cause stack"</span> &lt;&lt; i &lt;&lt; <span class="string">" is empty"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isEmpty(stackId)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> stackId;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> index = stackId*size + pointer[stackId];</span><br><span class="line">				<span class="keyword">return</span> buffer[index - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to top cause stack"</span> &lt;&lt; i &lt;&lt; <span class="string">" is empty"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述平均分配的方法浪费空间</span></span><br><span class="line"><span class="comment">// 因此想到的方法就应该是统一从数组中分配，但是出栈的时候就会麻烦，因为不知道某个堆栈前一个的位置</span></span><br><span class="line"><span class="comment">// 因此我们在存放数据的时候，也应该保存它前一个的位置，这样就可以找回去</span></span><br><span class="line"><span class="comment">// 结点结构需要重新定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Item &#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	<span class="keyword">int</span> preIndex;</span><br><span class="line">	Item() &#123;&#125;</span><br><span class="line">	Item(<span class="keyword">int</span> v, <span class="keyword">int</span> p) :value(v), preIndex(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ArrayToThreeStack2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">300</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> stackNum = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Item buffer[size];</span><br><span class="line">	<span class="keyword">int</span> pointer[stackNum];</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ArrayToThreeStack2() &#123;</span><br><span class="line">		<span class="built_in">memset</span>(buffer, <span class="literal">NULL</span>, size*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">		<span class="built_in">memset</span>(pointer, <span class="number">-1</span>, stackNum*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">		index = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (pointer[stackId] == <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (index == size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackId, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isFull(stackId)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> stackId;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> previous = pointer[stackId];</span><br><span class="line">				pointer[stackId] = index++;</span><br><span class="line">				Item* newItem = <span class="keyword">new</span> Item(value, previous);</span><br><span class="line">				buffer[pointer[stackId]] = *newItem;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to push cause stack is full"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isEmpty(stackId)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> stackId;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> previous = buffer[pointer[stackId]].preIndex;</span><br><span class="line">				pointer[stackId] = previous;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to pop cause stack"</span> &lt;&lt; i &lt;&lt; <span class="string">" is empty"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isEmpty(stackId)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> stackId;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> buffer[pointer[stackId]].value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to top cause stack"</span> &lt;&lt; i &lt;&lt; <span class="string">" is empty"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述方法仍然存在一个问题，那就是每次出栈的时候空间并没有被回收，即index并没有减小。新申请的空间还是在index之后的。</span></span><br><span class="line"><span class="comment">// 因此频繁的出栈入栈会造成空间的大量浪费</span></span><br><span class="line"><span class="comment">// 解决的方案是每次出栈，跟index比较，如果比index小，那么更新index</span></span><br><span class="line"><span class="comment">// 每次push一个新的，需要更新index,即向后寻找第一个空的位置</span></span><br><span class="line"><span class="comment">// 这样虽然节省了空间，但是浪费了时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ArrayToThreeStack3 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">300</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> stackNum = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Item buffer[size];</span><br><span class="line">	<span class="keyword">int</span> pointer[stackNum];</span><br><span class="line">	<span class="keyword">int</span> index;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ArrayToThreeStack3() &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			buffer[i].value = <span class="number">0</span>;</span><br><span class="line">			buffer[i].preIndex = <span class="number">-2</span>; <span class="comment">//代表为空</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(pointer, <span class="number">-1</span>, stackNum*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">		index = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (pointer[stackId] == <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (index == size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackId, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isFull(stackId)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> stackId;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> previous = pointer[stackId];</span><br><span class="line">				pointer[stackId] = index;</span><br><span class="line">				Item* newItem = <span class="keyword">new</span> Item(value, previous);</span><br><span class="line">				buffer[pointer[stackId]] = *newItem;</span><br><span class="line">				<span class="keyword">int</span> i;</span><br><span class="line">				<span class="keyword">for</span> (i = index + <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (buffer[i].preIndex == <span class="number">-2</span>) &#123;</span><br><span class="line">						index = i;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (i == size) &#123; <span class="comment">//没找到空的位置</span></span><br><span class="line">					index = size;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to push cause stack is full"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isEmpty(stackId)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> stackId;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> previous = buffer[pointer[stackId]].preIndex;</span><br><span class="line">				buffer[pointer[stackId]].value = <span class="number">0</span>;</span><br><span class="line">				buffer[pointer[stackId]].preIndex = <span class="number">-2</span>; </span><br><span class="line">				<span class="keyword">if</span> (pointer[stackId] &lt; index) &#123;</span><br><span class="line">					index = pointer[stackId];</span><br><span class="line">				&#125;</span><br><span class="line">				pointer[stackId] = previous;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to pop cause stack"</span> &lt;&lt; i &lt;&lt; <span class="string">" is empty"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">(<span class="keyword">int</span> stackId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (isEmpty(stackId)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> stackId;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> buffer[pointer[stackId]].value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to top cause stack"</span> &lt;&lt; i &lt;&lt; <span class="string">" is empty"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ArrayToThreeStack3 <span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">array</span>.push(<span class="number">0</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">array</span>.push(<span class="number">1</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">array</span>.top(<span class="number">1</span>) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">		<span class="built_in">array</span>.pop(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">array</span>.pop(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-2-How-would-you-design-a-stack-which-in-addition-to-push-and-pop-also-has-a-function-min-which-returns-the-minimum-element-Push-pop-and-min-should-all-operate-in-O-1-time"><a href="#3-2-How-would-you-design-a-stack-which-in-addition-to-push-and-pop-also-has-a-function-min-which-returns-the-minimum-element-Push-pop-and-min-should-all-operate-in-O-1-time" class="headerlink" title="3.2 How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element? Push, pop and min should all operate in O(1) time."></a><strong>3.2 How would you design a stack which, in addition to push and pop, also has a function min which returns the minimum element? Push, pop and min should all operate in O(1) time.</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一个栈，出了实现push和pop操作，还要实现min函数返回栈中的最小值。要求push,pop,min函数的时间复杂度都是O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//维持一个全局最小值的方法不再适用，因为每次从栈中弹出一个元素并没有办法更新这个全局最小值</span></span><br><span class="line"><span class="comment">//因此应该在每一个节点维持一个局部最小值，即到该结点入栈时栈中的局部最小值</span></span><br><span class="line"><span class="comment">//因此重新设计结点的结构</span></span><br><span class="line"><span class="keyword">struct</span> Node &#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line">    Node(<span class="keyword">int</span> v, <span class="keyword">int</span> m):val(v),min(m)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Mystack &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;Node*&gt; s;</span><br><span class="line">    <span class="keyword">int</span> curMin;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Mystack()&#123;</span><br><span class="line">        curMin = MIN.MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; curMin) &#123;</span><br><span class="line">            curMin = val;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *newNode = <span class="keyword">new</span> Node(val, curMin);</span><br><span class="line">        s.push(*newNode);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top().val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top().min;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mystack ms;</span><br><span class="line">    ms.push(<span class="number">2</span>);</span><br><span class="line">    ms.push(<span class="number">4</span>);</span><br><span class="line">    ms.push(<span class="number">1</span>);</span><br><span class="line">    ms.push(<span class="number">2</span>);</span><br><span class="line">    ms.push(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ms.min() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    ms.pop();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ms.min() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    ms.pop();</span><br><span class="line">    ms.pop();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ms.top() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ms.min() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-3-Imagine-a-literal-stack-of-plates-If-the-stack-gets-too-high-it-might-topple-Therefore-in-real-life-we-would-likely-start-a-new-stack-when-the-previous-stack-exceeds-some-threshold-Implement-a-data-structure-SetOfStacks-that-mimics-this-SetOfStacks-should-be-composed-of-several-stacks-and-should-create-a-new-stack-once-the-previous-one-exceeds-capacity-SetOfStacks-push-and-SetOfStacks-pop-should-behave-identically-to-a-single-stack-that-is-pop-should-return-the-same-values-as-it-would-if-there-were-just-a-single-stack-FOLLOW-UP-Implement-a-function-popAt-int-index-which-performs-a-pop-operation-on-a-specific-sub-stack"><a href="#3-3-Imagine-a-literal-stack-of-plates-If-the-stack-gets-too-high-it-might-topple-Therefore-in-real-life-we-would-likely-start-a-new-stack-when-the-previous-stack-exceeds-some-threshold-Implement-a-data-structure-SetOfStacks-that-mimics-this-SetOfStacks-should-be-composed-of-several-stacks-and-should-create-a-new-stack-once-the-previous-one-exceeds-capacity-SetOfStacks-push-and-SetOfStacks-pop-should-behave-identically-to-a-single-stack-that-is-pop-should-return-the-same-values-as-it-would-if-there-were-just-a-single-stack-FOLLOW-UP-Implement-a-function-popAt-int-index-which-performs-a-pop-operation-on-a-specific-sub-stack" class="headerlink" title="3.3 Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure SetOfStacks that mimics this. SetOfStacks should be composed of several stacks, and should create a new stack once the previous one exceeds capacity. SetOfStacks.push() and SetOfStacks.pop() should behave identically to a single stack (that is, pop() should return the same values as it would if there were just a single stack). FOLLOW UP: Implement a function popAt(int index) which performs a pop operation on a specific sub-stack."></a><strong>3.3 Imagine a (literal) stack of plates. If the stack gets too high, it might topple. Therefore, in real life, we would likely start a new stack when the previous stack exceeds some threshold. Implement a data structure SetOfStacks that mimics this. SetOfStacks should be composed of several stacks, and should create a new stack once the previous one exceeds capacity. SetOfStacks.push() and SetOfStacks.pop() should behave identically to a single stack (that is, pop() should return the same values as it would if there were just a single stack). FOLLOW UP: Implement a function popAt(int index) which performs a pop operation on a specific sub-stack.</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现多个栈，当前栈满了的时候，将数据放入一个新的栈中。出栈和入栈的行为需要和只有一个栈的情况一样</span></span><br><span class="line"><span class="comment">// 进一步实现函数在指定子栈上出栈</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先不考虑popAt函数</span></span><br><span class="line"><span class="comment">// 需要一个指向当前栈的变量 每次入栈的时候检查当前栈是否满了，如果满了的话就将该变量加1</span></span><br><span class="line"><span class="comment">// 每次出栈的时候检查当前栈是否为空，如果为空就将该变量减1</span></span><br><span class="line"><span class="comment">// 因此看起来是多个栈，其实都在最后一个子栈上进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SetOfStacks &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> stackNum = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> stackSize = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> cur;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;* s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SetOfStacks() &#123;</span><br><span class="line">		cur = <span class="number">0</span>;</span><br><span class="line">		s = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;[stackNum];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~ SetOfStacks() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[cur].size() == stackSize) &#123;</span><br><span class="line">			cur++;</span><br><span class="line">			<span class="keyword">if</span> (cur == stackNum) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to push"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		s[cur].push(val);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[cur].size() == <span class="number">0</span>) &#123;</span><br><span class="line">			cur--;</span><br><span class="line">			<span class="keyword">if</span> (cur == <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to pop"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		s[cur].pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[cur].size() == <span class="number">0</span>) &#123;</span><br><span class="line">			cur--;</span><br><span class="line">			<span class="keyword">if</span> (cur == <span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to top"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> s[cur].top();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于FOLLOW UP 问题</span></span><br><span class="line"><span class="comment">// 实现对于指定子栈的出栈操作</span></span><br><span class="line"><span class="comment">// 如果执行出栈的栈不是当前子栈，那么就考虑将出栈后面的那个栈的最底层元素入栈</span></span><br><span class="line"><span class="comment">// 当然我们也可以假设不考虑空间的回收利用，即允许除了最后一个栈的其他栈为空</span></span><br><span class="line"><span class="comment">// 具体的要求要跟面试官讨论，这里不展开论述了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	SetOfStacks ss;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">		ss.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">150</span>; i++) &#123;</span><br><span class="line">		ss.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/17/C2/" itemprop="url">
                  Ctci 读书笔记（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-17T23:33:11+08:00" content="2016-05-17">
              2016-05-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/面试/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/05/17/C2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/05/17/C2/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Chapter-2-Linked-Lists"><a href="#Chapter-2-Linked-Lists" class="headerlink" title="Chapter 2 Linked Lists"></a>Chapter 2 Linked Lists</h2><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>链表操作在面试中很常见。链表和数组最大的区别是插入和删除节点的时间复杂度是O(1)，而查找的时间复杂度是O(N)。面试者必须掌握如何创建一个链表，插入，删除一个节点。<br>C++ STL中list实现了双向链表的功能。以下是例子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Constructor</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l1; <span class="comment">//empty list</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l2(<span class="number">4</span>, <span class="number">1</span>); <span class="comment">// 4 ints with value 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l3(l2.begin(), l2.end()); <span class="comment">//iterating through l2</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; l4&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">// 3 ints with values 1,2,3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Iterator</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span>(it = l4.begin(); it != l4.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Add and delete last element </span></span><br><span class="line">    l4.push_back(<span class="number">4</span>);</span><br><span class="line">    l4.push_back(<span class="number">5</span>);</span><br><span class="line">    l4.pop_back();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Add and delete first element</span></span><br><span class="line">    l4.push_front(<span class="number">0</span>);</span><br><span class="line">    l4.push_front(<span class="number">-1</span>);</span><br><span class="line">    l4.pop_front();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Access first and last element</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"First element of l4 is: "</span> &lt;&lt; l4.front &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Last element of l4 is: "</span> &lt;&lt; <span class="number">14.</span>back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Assign new content </span></span><br><span class="line">    l1 = l4;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of l1: "</span> &lt;&lt; l1.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    l4.assign(l2.begin(), l2.end());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of l4: "</span> &lt;&lt; l4.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Insert and erase element at any position</span></span><br><span class="line">    l4.insert(l4.begin()+<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">    l4.erase(l4.end()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复杂的链表操作并不常见，而且我们需要链表的时候一般是自己实现一个链表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node &#123;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node(<span class="keyword">int</span> val):value(val), next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往链表的末尾添加新结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addToTail</span><span class="params">(Node* &amp;head, <span class="keyword">int</span> val)</span> </span>&#123; <span class="comment">// 这里要注意，head是一个引用指针类型。因为如果链表为空，那么我们往里面插入一个节点，就会改变头指针。因此必须把head设置为可以改变指针值的指针，否则出了这个函数head仍然是一个空指针</span></span><br><span class="line">    Node* newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        head = newNode; <span class="comment">// 容易忽略往空链表插入节点的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) p = p-&gt;next;</span><br><span class="line">        p-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第一个指定值的结点</span></span><br><span class="line"><span class="comment">// 分别考虑删除的是头结点，中间结点和尾结点的情况</span></span><br><span class="line"><span class="comment">// 同时要考虑到链表不含指定值的情况,以及空链表的情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteOfTail</span><span class="params">(Node* &amp;head, <span class="keyword">int</span> val)</span> </span>&#123; <span class="comment">//同理，头指针也要设置为引用类型，因为有可能被改变</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node* pdelete = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;value == val) &#123; <span class="comment">//删除的是头结点</span></span><br><span class="line">        pdelete = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node* p = head;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;value != val) &#123; <span class="comment">//循环跳出有两种条件：一是走到了末尾仍没有找到指定值，二是找到了指定值；尾结点和中间节点可以合并</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;value == val) &#123;</span><br><span class="line">            pdelete = p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pdelete!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> pdelete;</span><br><span class="line">        pdelete = <span class="literal">NULL</span>; <span class="comment">//set pointer to NULL after deletion</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><h4 id="2-1-Write-code-to-remove-duplicates-from-an-unsorted-linked-list-FOLLOW-UP-How-would-you-solve-this-problem-if-a-temporary-buffer-is-not-allowed"><a href="#2-1-Write-code-to-remove-duplicates-from-an-unsorted-linked-list-FOLLOW-UP-How-would-you-solve-this-problem-if-a-temporary-buffer-is-not-allowed" class="headerlink" title="2.1 Write code to remove duplicates from an unsorted linked list. FOLLOW UP: How would you solve this problem if a temporary buffer is not allowed?"></a><strong>2.1 Write code to remove duplicates from an unsorted linked list. FOLLOW UP: How would you solve this problem if a temporary buffer is not allowed?</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这道题和1.3基本一模一样，只是数据结构从数组变成了链表， 并且没有指明元素的类型，假设是int。同样可以运用1.3的方法。需要注意的是，由于链表删除能做到O(1),因此不必使用两个指针复制来模拟删除，可以直接在原始链表上删除。因此如果使用额外空间，可以无需使用两个指针并在O(N)时间复杂度下完成；如果不允许使用额外数组空间，那么对于每个结点，是不知道之前出现过没有的，因此需要从头遍历到该节点然后删除出现过的节点；也可以使用向后遍历的做法，对于每个结点，向后遍历删除出现过的节点，时间复杂度为O(N^2)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开一个数组来保存元素的出现情况。由于数值是整形，有可能非常大，并且可能有负数，因此用数组下标索引实现的hash表没那么高效。由于题目是链表，因此我们直接使用STL里面的unorder_set就好(这里不用unordered_map的原因是我们只需要判断key在不在就可以了)</span></span><br><span class="line"><span class="comment">// 解法一：</span></span><br><span class="line"><span class="comment">// 时间复杂度： O(cN) c为hash表查找冲突次数</span></span><br><span class="line"><span class="comment">// 空间复杂度： O(C) C为hash的容量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> Node &#123;</span><br><span class="line">	Node* next;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Node(<span class="keyword">int</span> val) :value(val), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeDup</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; uset;</span><br><span class="line">	uset.insert(head-&gt;value);</span><br><span class="line">	Node* p = head;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		it = uset.find(p-&gt;next-&gt;value);</span><br><span class="line">		<span class="keyword">if</span> (it == uset.end()) &#123;</span><br><span class="line">			uset.insert(p-&gt;next-&gt;value);</span><br><span class="line">			p = p-&gt;next; <span class="comment">// 这有bug 不能放到if的外面。因为如果执行了删除的话，是不能移位的</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			Node* tmp = p-&gt;next;</span><br><span class="line">			p-&gt;next = tmp-&gt;next;</span><br><span class="line">			<span class="keyword">delete</span> tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向后遍历删除</span></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(N^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeDup2</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span> ||  head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	Node* p = head;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Node* q = p;</span><br><span class="line">		<span class="keyword">while</span> (q-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;next-&gt;value == p-&gt;value) &#123;</span><br><span class="line">				Node* tmp = q-&gt;next;</span><br><span class="line">				q-&gt;next = tmp-&gt;next;</span><br><span class="line">				<span class="keyword">delete</span> tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				q = q-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Node* head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">	head-&gt;next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">	head-&gt;next-&gt;next = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">	head-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">	head-&gt;next-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">	head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">	removeDup2(head);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-2-Implement-an-algorithm-to-find-the-nth-to-last-element-of-a-singly-linked-list"><a href="#2-2-Implement-an-algorithm-to-find-the-nth-to-last-element-of-a-singly-linked-list" class="headerlink" title="2.2 Implement an algorithm to find the nth to last element of a singly linked list"></a><strong>2.2 Implement an algorithm to find the nth to last element of a singly linked list</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找链表倒数第K个节点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> Node &#123;</span><br><span class="line">	Node* next;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Node(<span class="keyword">int</span> val) :value(val), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先应该想到，通过第一次遍历得到链表的长度l，然后第二次遍历到l-n+1个节点就是所求</span></span><br><span class="line"><span class="comment">// 解法1：</span></span><br><span class="line"><span class="comment">// 时间复杂度:O(N)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="function">Node* <span class="title">findNthToLastElem</span><span class="params">(Node* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">	Node* p = head;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		l++;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (l &lt; n) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> N = l - n + <span class="number">1</span>;</span><br><span class="line">	p = head;</span><br><span class="line">	<span class="keyword">while</span> (--N) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只允许遍历一次链表，那么可以设置两个指针</span></span><br><span class="line"><span class="comment">// 第一个指针先走n步，然后两个指针一起走，当第一个指针为NULL时，第二个指针指向即为所求</span></span><br><span class="line"><span class="comment">// 解法2：</span></span><br><span class="line"><span class="comment">// 时间复杂度O(N)</span></span><br><span class="line"><span class="comment">// 空间复杂度O(1)</span></span><br><span class="line"><span class="function">Node* <span class="title">findNthToLastElem2</span><span class="params">(Node* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	Node *p = head, *q = head;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p != <span class="literal">NULL</span>) p = p-&gt;next;</span><br><span class="line">		<span class="comment">//这里需要特别注意if判断。因为如果l小于n的话，p走不了l步，程序会崩溃</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> q;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Node* head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">	head-&gt;next = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">	head-&gt;next-&gt;next = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">	head-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">	head-&gt;next-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">	head-&gt;next-&gt;next-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	Node* res = findNthToLastElem2(head, <span class="number">7</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="2-3-Implement-an-algorithm-to-delete-a-node-in-the-middle-of-a-single-linked-list-given-only-access-to-that-node"><a href="#2-3-Implement-an-algorithm-to-delete-a-node-in-the-middle-of-a-single-linked-list-given-only-access-to-that-node" class="headerlink" title="2.3 Implement an algorithm to delete a node in the middle of a single linked list, given only access to that node"></a><strong>2.3 Implement an algorithm to delete a node in the middle of a single linked list, given only access to that node</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只给中间结点，不给头结点实现结点的删除</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> Node &#123;</span><br><span class="line">	Node* next;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Node(<span class="keyword">int</span> val) :value(val), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟删除</span></span><br><span class="line"><span class="comment">// 把下一个结点的值复制过来，然后删除下一个结点</span></span><br><span class="line"><span class="comment">// 这种模拟删除的方法不适用于结点是尾结点的情况，但是由于题目已经说明是中间结点，所以可以用这种方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteMiddleNode</span><span class="params">(Node* pdelete)</span> </span>&#123;</span><br><span class="line">    pdelete-&gt;value = pdelete-&gt;next-&gt;value;</span><br><span class="line">    pdelete-&gt;next = pdelete-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> pdelete-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.JPG"
               alt="Luting" />
          <p class="site-author-name" itemprop="name">Luting</p>
          <p class="site-description motion-element" itemprop="description">程序媛的日常</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016.5 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Luting</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"luting"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
